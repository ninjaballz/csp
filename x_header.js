/*
  Haraka Unified Mail Optimization Plugin
  ---------------------------------------
  Features (all-in-one):
    1. Subject encoding (UTF-8 or ISO-2022-JP) with RFC 2047 encoded-words.
       - Auto-detect Japanese legacy/mobile domains for ISO-2022-JP (configurable).
       - Skips double-encoding if Subject already encoded.
    2. Per-recipient cryptographic unsubscribe token + List-Unsubscribe headers (URL + mailto + One-Click).
       - HMAC-based deterministic (time-bucket) or per-send mode.
       - Optional placeholder replacement: {{UNSUB_URL}} and {{UNSUB_MAILTO}} in body (HTML or plain text).
    3. Deliverability-focused headers (Feedback-ID, List-ID, Precedence (optional), Auto-Submitted (optional),
       X-Auto-Response-Suppress, stable X-Mailer, Message-ID if missing).
    4. Minimal safe HTML hygiene (charset/meta/style injection, optional microdata, basic image normalization).
    5. Recipient placeholders: {{RECIPIENT_EMAIL}}, {{RECIPIENT_EMAIL_MASKED}}, {{RECIPIENT_USERNAME}}, {{RECIPIENT_DOMAIN}}.

  Installation:
    npm install iconv-lite

  Add to haraka/config/plugins:
    unified_mail_opt

  Environment:
    UNSUB_SECRET  (strong random secret, or set in CONFIG below)

  NOTE:
    - For DKIM signing, ensure this plugin runs BEFORE dkimsign (so final headers & subject are in place).
    - For transactional mail, set CONFIG.bulk = false and disable Precedence/Auto-Submitted if user-triggered.

  Author: (You)
*/

const crypto = require('crypto');
const iconv = require('iconv-lite');

// --------------------- CONFIG ---------------------
const CONFIG = {
  // Subject encoding / detection
  forceUtf8Only: false,          // if true, always UTF-8
  useIso2022ForCarriers: true,   // attempt ISO-2022-JP for certain Japanese mobile domains
  iso2022FallbackToUtf8: true,   // fallback to UTF-8 if ISO-2022-JP loses characters (replacement '?')
  carrierDomainRegex: /(@|\.)(docomo\.ne\.jp|ezweb\.ne\.jp|au\.com|softbank\.ne\.jp)$/i,

  // Unsubscribe + headers
  enableListHeaders: true,
  enableUnsubPlaceholders: true,   // replace {{UNSUB_URL}} / {{UNSUB_MAILTO}} if present
  unsubscribeBaseURL: 'https://mail.example.com/unsub',
  unsubscribeMailLocal: 'unsubscribe',
  unsubscribeSecret: process.env.UNSUB_SECRET || 'CHANGE_ME_TO_LONG_RANDOM_SECRET',
  unsubscribePathMode: 'path',     // 'path' or 'query'
  unsubTimeBucketHours: 1,         // rotate token hourly
  perSendUnsubToken: false,        // true to force unique per message
  listIdLocalPart: 'newsletter',   // List-ID local part
  campaignId: 'general',           // for Feedback-ID
  customerId: 'default',
  mailType: 'newsletter',          // e.g., newsletter | notification | receipt
  bulk: true,                      // bulk vs transactional
  autoGenerated: true,             // mark as auto-generated (if not user-originated)
  addPrecedence: true,             // only if bulk
  addFeedbackID: true,
  addListID: true,

  // Subject config
  maxEncodedWordLength: 75,
  xMailer: 'UnifiedMailer/1.0',
  setStableMailerHeader: true,

  // Placeholders
  enableRecipientPlaceholders: true,

  // HTML tweaks
  enableHtmlProcessing: true,
  enableMicrodata: true,
  enableImageNormalization: true,

  // Body hash headers (diagnostic)
  addBodyHashHeaders: false,

  // Logging noise control
  logSubjectEncoding: true,
  logUnsub: true,
};

// --------------------- UTILITIES ---------------------
function sha256(data) {
  return crypto.createHash('sha256').update(data).digest('hex');
}

function base64Url(input) {
  return Buffer.from(input).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
}

function decodeBase64Url(str) {
  str = str.replace(/-/g, '+').replace(/_/g, '/');
  while (str.length % 4) str += '=';
  return Buffer.from(str, 'base64').toString();
}

function hmacSignature(secret, payload) {
  return crypto.createHmac('sha256', secret).update(payload).digest('base64url').slice(0, 32);
}

function makeMessageId(domain) {
  const ts = Date.now();
  const rnd = crypto.randomBytes(8).toString('hex');
  return `<${ts}.${rnd}@${domain || 'localhost'}>`;
}

function parseRecipient(txn) {
  if (!txn.rcpt_to || !txn.rcpt_to.length) return null;
  const email = txn.rcpt_to[0].address();
  const [local, domain] = email.split('@');
  return { email, local, domain };
}

function getRootDomain(domainFull) {
  const parts = domainFull.split('.');
  // basic handling of co.jp style
  if (domainFull.endsWith('.co.jp') && parts.length >= 3) return parts.slice(-3).join('.');
  if (parts.length >= 2) return parts.slice(-2).join('.');
  return domainFull;
}

function getSubdomain(domainFull, rootDomain) {
  if (domainFull === rootDomain) return 'mail';
  const idx = domainFull.lastIndexOf('.' + rootDomain);
  if (idx <= 0) return 'mail';
  return domainFull.substring(0, idx);
}

// --------------------- SUBJECT ENCODING ---------------------
function encodeSubjectRFC2047(text, charset, maxEncodedWordLength) {
  if (!text) return '';
  // ASCII safe?
  if (/^[\x20-\x7E]*$/.test(text)) return text;

  let buf;
  if (/^utf-8$/i.test(charset)) {
    buf = Buffer.from(text, 'utf8');
  } else if (/^iso-2022-jp$/i.test(charset)) {
    buf = iconv.encode(text, 'ISO-2022-JP');
  } else {
    throw new Error(`Unsupported charset: ${charset}`);
  }

  const overhead = 2 + charset.length + 3 + 2; // =? + charset + ?B? + ?=
  const maxB64Len = maxEncodedWordLength - overhead;

  const chunks = [];
  let start = 0;
  while (start < buf.length) {
    let end = Math.min(buf.length, start + Math.ceil((maxB64Len * 3) / 4));
    let slice = buf.subarray(start, end);
    let b64 = slice.toString('base64');
    while (b64.length > maxB64Len && slice.length > 1) {
      end--;
      slice = buf.subarray(start, end);
      b64 = slice.toString('base64');
    }
    if (!slice.length) {
      slice = buf.subarray(start, start + 1);
      b64 = slice.toString('base64');
      if (b64.length > maxB64Len) {
        throw new Error('Single-byte overflow; cannot encode.');
      }
      end = start + 1;
    }
    chunks.push(`=?${charset}?B?${b64}?=`);
    start = end;
  }
  return chunks.join(' ');
}

function needsEncoding(subject) {
  // Already encoded-word?
  return !/=\?.+\?[bqBQ]\?.+\?=/.test(subject);
}

function chooseCharset(rcptEmail) {
  if (CONFIG.forceUtf8Only) return 'UTF-8';
  if (CONFIG.useIso2022ForCarriers && rcptEmail && CONFIG.carrierDomainRegex.test(rcptEmail)) {
    return 'ISO-2022-JP';
  }
  return 'UTF-8';
}

function encodeSubjectSmart(originalSubject, rcptEmail, logger) {
  if (!originalSubject) return originalSubject;
  if (!needsEncoding(originalSubject)) {
    return originalSubject; // already encoded
  }
  const chosen = chooseCharset(rcptEmail);
  let encoded;
  try {
    encoded = encodeSubjectRFC2047(originalSubject, chosen, CONFIG.maxEncodedWordLength);
    if (chosen === 'ISO-2022-JP' && CONFIG.iso2022FallbackToUtf8) {
      // Heuristic: if too many '?' replacements vs original non-ASCII count
      const nonAscii = (originalSubject.match(/[^\x00-\x7F]/g) || []).length;
      const qMarks = (iconv.decode(iconv.encode(originalSubject, 'ISO-2022-JP'), 'ISO-2022-JP').match(/\?/g) || []).length;
      if (nonAscii && qMarks / nonAscii > 0.5) {
        const utf8Encoded = encodeSubjectRFC2047(originalSubject, 'UTF-8', CONFIG.maxEncodedWordLength);
        if (logger && CONFIG.logSubjectEncoding) logger.loginfo(`Fallback to UTF-8 subject encoding (ISO-2022-JP loss detected)`);
        return utf8Encoded;
      }
    }
    return encoded;
  } catch (e) {
    if (logger) logger.logerror(`Subject encoding error: ${e.message} (fallback UTF-8)`);
    try {
      return encodeSubjectRFC2047(originalSubject, 'UTF-8', CONFIG.maxEncodedWordLength);
    } catch {
      return originalSubject; // last resort
    }
  }
}

// --------------------- UNSUBSCRIBE LOGIC ---------------------
function generateUnsubToken(email, campaignId, secret) {
  const nowBucket = CONFIG.perSendUnsubToken
    ? crypto.randomBytes(6).toString('base64url')
    : Math.floor(Date.now() / (1000 * 60 * 60 * CONFIG.unsubTimeBucketHours));
  const payload = `${email}|${campaignId}|${nowBucket}`;
  const sig = hmacSignature(secret, payload);
  const tokenRaw = `${payload}|${sig}`;
  return base64Url(tokenRaw);
}

function buildUnsubData(txn, rootDomain, host) {
  if (!CONFIG.enableListHeaders) return null;
  const rcpt = parseRecipient(txn);
  if (!rcpt) return null;

  const email = rcpt.email;
  const token = generateUnsubToken(email, CONFIG.campaignId, CONFIG.unsubscribeSecret);

  let url;
  if (CONFIG.unsubscribePathMode === 'query') {
    url = `${CONFIG.unsubscribeBaseURL}?t=${encodeURIComponent(token)}`;
  } else {
    // Path mode
    url = `${CONFIG.unsubscribeBaseURL.replace(/\/$/, '')}/${encodeURIComponent(token)}`;
  }
  const mailto = `mailto:${CONFIG.unsubscribeMailLocal}@${host}?subject=unsubscribe&body=${encodeURIComponent(email)}`;

  return { email, token, url, mailto };
}

// --------------------- PLACEHOLDERS ---------------------
function maskEmail(email) {
  const [local, domain] = email.split('@');
  if (!domain) return email;
  if (local.length <= 2) return `${local[0]}*@${domain}`;
  if (local.length <= 5) return `${local[0]}***${local.slice(-1)}@${domain}`;
  const start = local.slice(0, Math.min(3, Math.ceil(local.length * 0.3)));
  return `${start}***${local.slice(-1)}@${domain}`;
}

function replaceRecipientPlaceholders(content, rcpt) {
  if (!CONFIG.enableRecipientPlaceholders || !rcpt) return content;
  const masked = maskEmail(rcpt.email);
  const map = {
    '{{RECIPIENT_EMAIL}}': rcpt.email,
    '{{RECIPIENT_EMAIL_MASKED}}': masked,
    '{{RECIPIENT_USERNAME}}': rcpt.local,
    '{{RECIPIENT_DOMAIN}}': rcpt.domain
  };
  return content.replace(/{{RECIPIENT_EMAIL(?:_MASKED)?}}|{{RECIPIENT_USERNAME(?:_MASKED)?}}|{{RECIPIENT_DOMAIN}}/g, m => map[m] || m);
}

function replaceUnsubPlaceholders(content, unsubData) {
  if (!CONFIG.enableUnsubPlaceholders || !unsubData) return content;
  return content
    .replace(/{{UNSUB_URL}}/g, unsubData.url)
    .replace(/{{UNSUB_MAILTO}}/g, unsubData.mailto);
}

// --------------------- HTML PROCESSING ---------------------
function ensureDoctype(html) {
  return /<!doctype/i.test(html) ? html : '<!DOCTYPE html>\n' + html;
}

function ensureHeadMetaAndCss(html) {
  if (!/<head\b/i.test(html)) {
    html = html.replace(/<html[^>]*>/i, '$&\n<head></head>');
  }
  if (!/<meta[^>]+charset/i.test(html)) {
    html = html.replace(/<head[^>]*>/i, m => m + '\n<meta charset="UTF-8">');
  }
  if (!/viewport/i.test(html)) {
    html = html.replace(/<head[^>]*>/i, m => m + '\n<meta name="viewport" content="width=device-width,initial-scale=1">');
  }
  if (!/<style[^>]*>[^<]*body/i.test(html)) {
    const css = `
<style>
body { margin:0; padding:0; -webkit-text-size-adjust:100%; -ms-text-size-adjust:100%; }
img { border:0; height:auto; line-height:100%; outline:none; text-decoration:none; }
table { border-collapse:collapse; }
a { color:#1a73e8; }
</style>`;
    html = html.replace(/<\/head>/i, css + '\n</head>');
  }
  return html;
}

function addMicrodata(html) {
  if (!CONFIG.enableMicrodata) return html;
  if (!/itemscope/i.test(html)) {
    html = html.replace(/<body[^>]*>/i, m => m + '\n<div itemscope itemtype="http://schema.org/EmailMessage">');
    html = html.replace(/<\/body>/i, '</div>\n</body>');
  }
  return html;
}

function normalizeImages(html) {
  if (!CONFIG.enableImageNormalization) return html;
  return html.replace(/<img\b([^>]*)>/gi, (m, attrs) => {
    let updated = attrs;
    if (!/border=/i.test(updated)) updated += ' border="0"';
    if (!/style=/i.test(updated)) updated += ' style="display:block;max-width:100%;height:auto;"';
    if (!/loading=/i.test(updated)) updated += ' loading="lazy"';
    return `<img${updated}>`;
  });
}

function processHtmlPart(html, rcpt, unsubData) {
  if (!CONFIG.enableHtmlProcessing) return html;
  html = ensureDoctype(html);
  html = ensureHeadMetaAndCss(html);
  html = addMicrodata(html);
  html = normalizeImages(html);
  html = replaceRecipientPlaceholders(html, rcpt);
  html = replaceUnsubPlaceholders(html, unsubData);
  return html;
}

function processPlainText(text, rcpt, unsubData) {
  text = replaceRecipientPlaceholders(text, rcpt);
  text = replaceUnsubPlaceholders(text, unsubData);
  // Optional mild readability tweak
  return text.replace(/([.!?]) +([A-Z])/g, '$1\n\n$2');
}

// --------------------- HEADER ENRICHMENT ---------------------
function enrichHeaders(txn, unsubData, rootDomain, host, connection) {
  // Remove any previously set conflicting headers (idempotency)
  [
    'List-Unsubscribe', 'List-Unsubscribe-Post', 'Feedback-ID', 'List-ID',
    'Precedence', 'Auto-Submitted', 'X-Auto-Response-Suppress', 'X-Mailer'
  ].forEach(h => {
    while (txn.header.get_all(h).length) txn.remove_header(h);
  });

  if (CONFIG.enableListHeaders && unsubData) {
    txn.add_header('List-Unsubscribe', `<${unsubData.mailto}>, <${unsubData.url}>`);
    txn.add_header('List-Unsubscribe-Post', 'List-Unsubscribe=One-Click');
  }

  if (CONFIG.addListID) {
    txn.add_header('List-ID', `${CONFIG.listIdLocalPart}.${rootDomain}`);
  }

  if (CONFIG.addFeedbackID) {
    txn.add_header('Feedback-ID', `${CONFIG.campaignId}:${CONFIG.customerId}:${CONFIG.mailType}:${rootDomain}`);
  }

  if (CONFIG.bulk && CONFIG.addPrecedence) {
    txn.add_header('Precedence', 'bulk');
  }

  txn.add_header('X-Auto-Response-Suppress', 'All');

  if (CONFIG.autoGenerated) {
    txn.add_header('Auto-Submitted', 'auto-generated');
  }

  if (CONFIG.setStableMailerHeader && CONFIG.xMailer) {
    txn.add_header('X-Mailer', CONFIG.xMailer);
  }

  if (!txn.header.get('MIME-Version')) {
    txn.add_header('MIME-Version', '1.0');
  }

  if (!txn.header.get('Message-ID')) {
    txn.add_header('Message-ID', makeMessageId(rootDomain));
  }

  if (CONFIG.addBodyHashHeaders && txn._body_hash) {
    txn.add_header('X-Body-Hash', txn._body_hash);
  }

  if (CONFIG.logUnsub && unsubData) {
    connection.loginfo(`Unsub URL: ${unsubData.url}`);
  }
}

// --------------------- HARAKA HOOKS ---------------------
exports.register = function () {
  this.loginfo('Unified Mail Optimization Plugin loaded');
};

exports.hook_data_post = function (next, connection) {
  const txn = connection.transaction;
  if (!txn) return next();

  try {
    // Determine domain context
    const fromAddress = txn.mail_from && txn.mail_from.address();
    let domainFull = 'localhost';
    if (fromAddress && fromAddress.includes('@')) {
      domainFull = fromAddress.split('@')[1].toLowerCase();
    }
    const rootDomain = getRootDomain(domainFull);
    const subdomain = getSubdomain(domainFull, rootDomain).replace(/[^a-z0-9.-]/g, '') || 'mail';
    const host = `${subdomain}.${rootDomain}`;

    const rcpt = parseRecipient(txn);
    const unsubData = buildUnsubData(txn, rootDomain, host);

    // Process body parts
    let combinedHtml = '';
    let combinedText = '';
    if (txn.body) {
      if (txn.body.children && txn.body.children.length) {
        for (const part of txn.body.children) {
          const ct = (part.ct || '').toLowerCase();
            if (ct.includes('text/html')) {
              let html = part.bodytext.toString();
              html = processHtmlPart(html, rcpt, unsubData);
              part.bodytext = Buffer.from(html);
              combinedHtml += html;
            } else if (ct.includes('text/plain')) {
              let text = part.bodytext.toString();
              text = processPlainText(text, rcpt, unsubData);
              part.bodytext = Buffer.from(text);
              combinedText += text;
            }
        }
      } else if (txn.body.bodytext) {
        const raw = txn.body.bodytext.toString();
        if (/<html/i.test(raw)) {
          const html = processHtmlPart(raw, rcpt, unsubData);
          txn.body.bodytext = Buffer.from(html);
          combinedHtml = html;
        } else {
          const text = processPlainText(raw, rcpt, unsubData);
          txn.body.bodytext = Buffer.from(text);
          combinedText = text;
        }
      }
    }

    if (CONFIG.addBodyHashHeaders) {
      txn._body_hash = sha256(combinedHtml + '||' + combinedText);
    }

    // Subject encoding
    const originalSubject = txn.header.get('Subject') || '';
    const rcptEmail = rcpt && rcpt.email;
    const encodedSubject = encodeSubjectSmart(originalSubject, rcptEmail, connection);
    if (encodedSubject && encodedSubject !== originalSubject) {
      txn.remove_header('Subject');
      txn.add_header('Subject', encodedSubject);
      if (CONFIG.logSubjectEncoding) {
        connection.loginfo(`Subject encoded (${originalSubject !== encodedSubject ? 'changed' : 'unchanged'})`);
      }
    }

    // Enrich headers
    enrichHeaders(txn, unsubData, rootDomain, host, connection);

    next();
  } catch (err) {
    connection.logerror(`Unified optimization error: ${err.message}`);
    next();
  }
};

// --------------------- OPTIONAL EXPORTED HELPERS ---------------------
exports._internal = {
  encodeSubjectRFC2047,
  encodeSubjectSmart,
  generateUnsubToken,
  buildUnsubData,
  processHtmlPart,
  processPlainText
};
